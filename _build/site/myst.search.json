{"version":"1","records":[{"hierarchy":{"lvl1":"Contributing"},"type":"lvl1","url":"/contributing","position":0},{"hierarchy":{"lvl1":"Contributing"},"content":"Thank you for your interest in contributing to the CFSpy project!\nWe welcome contributions from the community to help improve and expand the\nfunctionality of this package. Below are some guidelines to help you get started.","type":"content","url":"/contributing","position":1},{"hierarchy":{"lvl1":"Contributing","lvl2":"How to Contribute"},"type":"lvl2","url":"/contributing#how-to-contribute","position":2},{"hierarchy":{"lvl1":"Contributing","lvl2":"How to Contribute"},"content":"Fork the Repository: Start by forking the ChenFliessSeries.jl repository on \n\nGitHub\nto your own account.\n\nClone Your Fork: Clone your forked repository to your local machine using:git clone\n\nCreate a Branch: Create a new branch for your feature or bug fix:git checkout -b feature/your-feature-name\n\nMake Changes: Implement your changes in the codebase. Ensure that your code follows the existing style and conventions.\n\nTest Your Changes: Write tests for your changes and run existing tests to ensure nothing is broken.\n\nCommit Your Changes: Commit your changes with a clear and descriptive commit message:git commit -m \"Add feature X to improve Y\"\n\nPush to Your Fork: Push your changes to your forked repository:git push origin feature/your-feature-name\n\nCreate a Pull Request: Go to the original ChenFliessSeries.jl repository and create a pull request from your forked repository. Provide a clear description of your changes and why they are needed.\n\nRespond to Feedback: Be prepared to discuss and make changes based on feedback from the project maintainers.\n\nCelebrate: Once your pull request is merged, celebrate your contribution to the ChenFliessSeries.jl project!","type":"content","url":"/contributing#how-to-contribute","position":3},{"hierarchy":{"lvl1":"Contributing","lvl2":"Guidelines"},"type":"lvl2","url":"/contributing#guidelines","position":4},{"hierarchy":{"lvl1":"Contributing","lvl2":"Guidelines"},"content":"Code Style: Follow the existing code style and conventions used in the project. This includes naming conventions, indentation, and documentation.\n\nDocumentation: Update the documentation to reflect any changes or new features you add.\n\nTesting: Ensure that your changes are covered by tests. This helps maintain the integrity of the codebase.\n\nRespect the Community: Be respectful and considerate in your interactions with other contributors and maintainers.\n\nStay Updated: Keep your forked repository up to date with the main repository to avoid conflicts.\n\nIssue Tracking: If you find a bug or have a feature request, please open an issue in the GitHub repository to discuss it before starting work.\n\nLicense: By contributing to this project, you agree that your contributions will be licensed under the same license as the project (MIT License).\n\nWe appreciate your contributions and look forward to collaborating with you to make CFSpy even better!","type":"content","url":"/contributing#guidelines","position":5},{"hierarchy":{"lvl1":"Examples"},"type":"lvl1","url":"/examples","position":0},{"hierarchy":{"lvl1":"Examples"},"content":"This section provides practical demonstrations of how to use\nCFSpy for computing iterated integrals, Lie derivatives,\nand truncated Chen–Fliess series for nonlinear control‑affine systems.\n\nEach example illustrates a complete workflow:\n\nDefine vector fields and outputs\n\nCompute Lie derivatives\n\nCompute iterated integrals\n\nAssemble the truncated Chen–Fliess series\n\nCompare with a numerical ODE solution\n\nTwo representative systems are shown below:a Lotka-Volterra and a SEIRS system.","type":"content","url":"/examples","position":1},{"hierarchy":{"lvl1":"Examples","lvl2":"Lotka-Volterra"},"type":"lvl2","url":"/examples#lotka-volterra","position":2},{"hierarchy":{"lvl1":"Examples","lvl2":"Lotka-Volterra"},"content":"This example demonstrates how to compute Lie derivatives, iterated integrals,\nand a truncated Chen–Fliess approximation for a simplified planar quadrotor.","type":"content","url":"/examples#lotka-volterra","position":3},{"hierarchy":{"lvl1":"Examples","lvl3":"System dynamics","lvl2":"Lotka-Volterra"},"type":"lvl3","url":"/examples#system-dynamics","position":4},{"hierarchy":{"lvl1":"Examples","lvl3":"System dynamics","lvl2":"Lotka-Volterra"},"content":"We consider the standard control–affine Lotka-Volterra model:    \\begin{aligned}\n    \\dot{x}_1 &= -x_1 x_2 + x_1 u_1, \\\\\n    \\dot{x}_2 &= x_1 x_2 - x_2 u_2, \n    \\end{aligned}\n\nwith output    y = h(x) = x_1.\n\nThis can be written in control–affine form    \\dot{x} = g_0(x) + g_1(x) u_1(t) + g_2(x) u_2(t),\n\nwhere    g_0(x) = \\begin{bmatrix} -x_1 x_2 \\\\ x_1 x_2 \\end{bmatrix},\n    \\quad\n    g_1(x) = \\begin{bmatrix} x_1 \\\\ 0  \\end{bmatrix},\n    \\quad\n    g_2(x) = \\begin{bmatrix} 0 \\\\ -x_2 \\end{bmatrix}.","type":"content","url":"/examples#system-dynamics","position":5},{"hierarchy":{"lvl1":"Examples","lvl3":"Defining the system in Python","lvl2":"Lotka-Volterra"},"type":"lvl3","url":"/examples#defining-the-system-in-python","position":6},{"hierarchy":{"lvl1":"Examples","lvl3":"Defining the system in Python","lvl2":"Lotka-Volterra"},"content":"import sympy as sp\n\n# Define the symbolic variables\nx1, x2 = sp.symbols('x1 x2')\nx = sp.Matrix([x1, x2])\n\n# The truncation of the length of the words that index the Chen-Fliess series\nNtrunc = 4\nh = x[1]                  # output: horizontal position\n\n# Define the system symbolically\ng = sp.transpose(sp.Matrix([[-x1*x2, x1*x2], [x1, 0], [0, - x2]]))\n\n# Define the output symbolically\nh = x1","type":"content","url":"/examples#defining-the-system-in-python","position":7},{"hierarchy":{"lvl1":"Examples","lvl3":"Input signal","lvl2":"Lotka-Volterra"},"type":"lvl3","url":"/examples#input-signal","position":8},{"hierarchy":{"lvl1":"Examples","lvl3":"Input signal","lvl2":"Lotka-Volterra"},"content":"import numpy as np\n# Time range\nt0 = 0\ntf = 3\ndt = 0.001\nt_span = (t0, tf)\n# Partition of the time interval\nt = np.linspace(t_span[0], t_span[1], int((tf-t0)//dt+1))\n# inputs as arrays\nu1 = np.sin(t)\nu2 = np.cos(t)\n\n# input array\nu = np.vstack([u1, u2])","type":"content","url":"/examples#input-signal","position":9},{"hierarchy":{"lvl1":"Examples","lvl3":"Computing iterated integrals","lvl2":"Lotka-Volterra"},"type":"lvl3","url":"/examples#computing-iterated-integrals","position":10},{"hierarchy":{"lvl1":"Examples","lvl3":"Computing iterated integrals","lvl2":"Lotka-Volterra"},"content":"from CFS import iter_int\n# List of iterated integral\nEu = iter_int(u,t0, tf, dt, Ntrunc)","type":"content","url":"/examples#computing-iterated-integrals","position":11},{"hierarchy":{"lvl1":"Examples","lvl3":"Computing Lie derivatives","lvl2":"Lotka-Volterra"},"type":"lvl3","url":"/examples#computing-lie-derivatives","position":12},{"hierarchy":{"lvl1":"Examples","lvl3":"Computing Lie derivatives","lvl2":"Lotka-Volterra"},"content":"from CFS import iter_lie\n# Initial condition\nx0 = [1/3,2/3]\n# Coefficients of the Chen-Fliess series evaluated at the initial state\nCeta = np.array(iter_lie(h,g,x,Ntrunc).subs([(x[0], x0[0]),(x[1], x0[1])]))","type":"content","url":"/examples#computing-lie-derivatives","position":13},{"hierarchy":{"lvl1":"Examples","lvl3":"Assembling the truncated Chen-Fliess series","lvl2":"Lotka-Volterra"},"type":"lvl3","url":"/examples#assembling-the-truncated-chen-fliess-series","position":14},{"hierarchy":{"lvl1":"Examples","lvl3":"Assembling the truncated Chen-Fliess series","lvl2":"Lotka-Volterra"},"content":"# Chen-Fliess series\nF_cu = x0[0]+np.sum(Ceta*Eu, axis = 0)","type":"content","url":"/examples#assembling-the-truncated-chen-fliess-series","position":15},{"hierarchy":{"lvl1":"Examples","lvl3":"Simulating the true Lotka-Volterra dynamics","lvl2":"Lotka-Volterra"},"type":"lvl3","url":"/examples#simulating-the-true-lotka-volterra-dynamics","position":16},{"hierarchy":{"lvl1":"Examples","lvl3":"Simulating the true Lotka-Volterra dynamics","lvl2":"Lotka-Volterra"},"content":"from scipy.integrate import solve_ivp\n\n# Define the Lotka-Volterra system\ndef system(t, x, u1_func, u2_func):\n    x1, x2 = x\n    u1 = u1_func(t)\n    u2 = u2_func(t)\n    dx1 = -x1*x2 +  x1 * u1\n    dx2 = x1*x2 - x2* u2\n    return [dx1, dx2]\n\n# Input 1\ndef u1_func(t):\n    return np.sin(t)\n\n# Input 2\ndef u2_func(t):\n    return np.cos(t)\n\n\n# Initial condition\nx0 = [1/3,2/3]\n\n# time\nt0 = 0\ntf = 3\ndt = 0.001\nt_span = (t0, tf)\n\n# Simulation of the system\nsolution = solve_ivp(system, t_span, x0, args=(u1_func, u2_func), dense_output=True)\n# Partition of the time interval\nt = np.linspace(t_span[0], t_span[1], int((tf-t0)//dt+1))\ny = solution.sol(t)","type":"content","url":"/examples#simulating-the-true-lotka-volterra-dynamics","position":17},{"hierarchy":{"lvl1":"Examples","lvl3":"Comparison plot","lvl2":"Lotka-Volterra"},"type":"lvl3","url":"/examples#comparison-plot","position":18},{"hierarchy":{"lvl1":"Examples","lvl3":"Comparison plot","lvl2":"Lotka-Volterra"},"content":"import matplotlib.pyplot as plt\n# Graph of the output and the Chen-Fliess series\nplt.figure(figsize = (12,5))\nplt.plot(t, y[0].T)\nplt.plot(t, F_cu, color='red', linewidth=5, linestyle = '--', alpha = 0.5)\nplt.xlabel('$t$')\nplt.ylabel('$x_1$')\nplt.legend(['Output of the system','Chen-Fliess series'])\nplt.grid()\nplt.show()","type":"content","url":"/examples#comparison-plot","position":19},{"hierarchy":{"lvl1":"Examples","lvl2":"SEIRS"},"type":"lvl2","url":"/examples#seirs","position":20},{"hierarchy":{"lvl1":"Examples","lvl2":"SEIRS"},"content":"This example illustrates how to compute a truncated Chen–Fliess series\nfor a SEIRS (Susceptible-Exposed-Infectious-Recovered-Susceptible) with torque input and compare it with the true\nODE solution.","type":"content","url":"/examples#seirs","position":21},{"hierarchy":{"lvl1":"Examples","lvl3":"System dynamics","lvl2":"SEIRS"},"type":"lvl3","url":"/examples#system-dynamics-1","position":22},{"hierarchy":{"lvl1":"Examples","lvl3":"System dynamics","lvl2":"SEIRS"},"content":"We consider the standard control–affine SEIRS model:\\begin{aligned}\n    \\dot{x}_1 &= \\mu N - u_1 x_3 x_1 / N + \\omega  x_4 - \\mu  x_1 \\\\\n    \\dot{x}_2 &= u_1 x_3 x_1 / N - \\sigma  x_2 - \\mu x_2 \\\\\n    \\dot{x}_3 &= \\sigma  x_2 - u_2 x_3 - (\\mu + \\alpha)  x_3 \\\\\n    \\dot{x}_4 &= u_2 x_3 - (\\omega + \\mu) x_4\n\\end{aligned}\n\nwith outputy = h(x) = x_1.\n\nThis can be written in control–affine form\\dot{x} = g_0(x) + g_1(x) u_1(t)+ g_2(x) u_2(t),\n\nwhereg_0(z) = \\begin{bmatrix} \\omega  x_4 - \\mu  x_1 \\\\ - \\sigma  x_2 - \\mu x_2 \\\\ \\sigma  x_2 - (\\mu + \\alpha)  x_3 \\\\ - (\\omega + \\mu) x_4 \\end{bmatrix},\n\\quad\ng_1(z) = \\begin{bmatrix} - x_3 x_1 / N \\\\ x_3 x_1 / N \\\\ 0 \\\\ 0 \\end{bmatrix},\n\\quad\ng_1(z) = \\begin{bmatrix} 0 \\\\ 0 \\\\ -x_3 \\\\ x_3 \\end{bmatrix}.","type":"content","url":"/examples#system-dynamics-1","position":23},{"hierarchy":{"lvl1":"Examples","lvl3":"Defining the system in Python","lvl2":"SEIRS"},"type":"lvl3","url":"/examples#defining-the-system-in-python-1","position":24},{"hierarchy":{"lvl1":"Examples","lvl3":"Defining the system in Python","lvl2":"SEIRS"},"content":"import sympy as sp\n# Define the symbolic variables\nx1, x2, x3, x4 = sp.symbols('x1 x2 x3 x4')\nx = sp.Matrix([x1, x2, x3, x4])\n\n\n# Define the system symbolically\nmu = 1 / 76\nomega = 1 \nsigma = 1 / 7\nalpha = 0\nN = 1.0\ng = sp.transpose(sp.Matrix([[mu * N + omega * x4 - mu * x1, - sigma * x2 - mu * x2, sigma * x2 - (mu + alpha) * x3, - omega * x4 - mu * x4], \\\n                            [-x3 * x1 / N, x3 * x1 / N, 0, 0], [0, 0, - x3, x3]]))\n\n# Define the output symbolically\nh = x1\n\n# The truncation of the length of the words that index the Chen-Fliess series\nNtrunc = 6","type":"content","url":"/examples#defining-the-system-in-python-1","position":25},{"hierarchy":{"lvl1":"Examples","lvl3":"Input signal","lvl2":"SEIRS"},"type":"lvl3","url":"/examples#input-signal-1","position":26},{"hierarchy":{"lvl1":"Examples","lvl3":"Input signal","lvl2":"SEIRS"},"content":"import numpy as np\n# Time range\nt0 = 0\ntf = 3\ndt = 0.001\nt_span = (t0, tf)\nt = np.linspace(t_span[0], t_span[1], int((tf-t0)//dt+1))\n# inputs as arrays\nu1 = np.sin(t)\nu2 = np.cos(t)\n\n# input array\nu = np.vstack([u1, u2])\n","type":"content","url":"/examples#input-signal-1","position":27},{"hierarchy":{"lvl1":"Examples","lvl3":"Computing iterated integrals","lvl2":"SEIRS"},"type":"lvl3","url":"/examples#computing-iterated-integrals-1","position":28},{"hierarchy":{"lvl1":"Examples","lvl3":"Computing iterated integrals","lvl2":"SEIRS"},"content":"# List of iterated integral\nEu = iter_int(u,t0, tf, dt, Ntrunc)","type":"content","url":"/examples#computing-iterated-integrals-1","position":29},{"hierarchy":{"lvl1":"Examples","lvl3":"Computing Lie derivatives","lvl2":"SEIRS"},"type":"lvl3","url":"/examples#computing-lie-derivatives-1","position":30},{"hierarchy":{"lvl1":"Examples","lvl3":"Computing Lie derivatives","lvl2":"SEIRS"},"content":"# Initial condition\nx0 = [0.999, 0.001, 0.0, 0.0]\n# The truncation of the length of the words that index the Chen-Fliess series\nNtrunc = 6\n# Coefficients of the Chen-Fliess series evaluated at the initial state\nCeta = np.array(iter_lie(h,g,x,Ntrunc).subs([(x[0], x0[0]),(x[1], x0[1]), (x[2], x0[2]), (x[3], x0[3])]))\n","type":"content","url":"/examples#computing-lie-derivatives-1","position":31},{"hierarchy":{"lvl1":"Examples","lvl3":"Assembling the truncated Chen–Fliess series","lvl2":"SEIRS"},"type":"lvl3","url":"/examples#assembling-the-truncated-chen-fliess-series-1","position":32},{"hierarchy":{"lvl1":"Examples","lvl3":"Assembling the truncated Chen–Fliess series","lvl2":"SEIRS"},"content":"# Chen-Fliess series\nF_cu = x0[0]+np.sum(Ceta*Eu, axis = 0)","type":"content","url":"/examples#assembling-the-truncated-chen-fliess-series-1","position":33},{"hierarchy":{"lvl1":"Examples","lvl3":"Simulating the true SEIRS dynamics","lvl2":"SEIRS"},"type":"lvl3","url":"/examples#simulating-the-true-seirs-dynamics","position":34},{"hierarchy":{"lvl1":"Examples","lvl3":"Simulating the true SEIRS dynamics","lvl2":"SEIRS"},"content":"from scipy.integrate import solve_ivp\n\nmu = 1 / 76\nomega = 1 \nsigma = 1 / 7\nalpha = 0\nN = 1.0\n\n# Define the SEIRS system\ndef system(t, x, u1_func, u2_func):\n    x1, x2, x3, x4 = x\n    u1 = u1_func(t)\n    u2 = u2_func(t)\n    dx1 = mu * N - u1 * x3 * x1 / N + omega * x4 - mu * x1\n    dx2 = u1 * x3 * x1 / N - sigma * x2 - mu * x2\n    dx3 = sigma * x2 - u2 * x3 - (mu + alpha) * x3\n    dx4 = u2 * x3 - omega * x4 - mu * x4\n    return [dx1, dx2, dx3, dx4]\n\n# Input 1\ndef u1_func(t):\n    return np.sin(t)\n\n# Input 2\ndef u2_func(t):\n    return np.cos(t)\n\n# Simulation of the system\nsolution = solve_ivp(system, t_span, x0, args=(u1_func, u2_func), dense_output=True)\n\n# Partition of the time interval\nt = np.linspace(t_span[0], t_span[1], int((tf-t0)//dt+1))\ny = solution.sol(t)","type":"content","url":"/examples#simulating-the-true-seirs-dynamics","position":35},{"hierarchy":{"lvl1":"Examples","lvl3":"Comparison plot","lvl2":"SEIRS"},"type":"lvl3","url":"/examples#comparison-plot-1","position":36},{"hierarchy":{"lvl1":"Examples","lvl3":"Comparison plot","lvl2":"SEIRS"},"content":"import matplotlib.pyplot as plt\n\nplt.figure(figsize = (12,5))\nplt.plot(t, y[0].T)\nplt.plot(t, F_cu, color='red', linewidth=5, linestyle = '--', alpha = 0.5)\nplt.xlabel('$t$')\nplt.ylabel('$x_1$')\nplt.legend(['Output of the system','Chen-Fliess series'])\nplt.grid()\nplt.show()","type":"content","url":"/examples#comparison-plot-1","position":37},{"hierarchy":{"lvl1":"Examples","lvl3":"Optimization and Reachability","lvl2":"SEIRS"},"type":"lvl3","url":"/examples#optimization-and-reachability","position":38},{"hierarchy":{"lvl1":"Examples","lvl3":"Optimization and Reachability","lvl2":"SEIRS"},"content":"from scipy.optimize import minimize\nfrom scipy.optimize import Bounds\n# Convert symbolic expression to a numerical function using lambdify\nsum_T_func = sp.lambdify([u1, u2], sp.Matrix(F_cu_substituted), 'numpy')\n\n# Define the objective function for scipy.optimize\ndef objective(x):\n    # x is an array [u1, u2]\n    return sum_T_func(x[0], x[1])\n\ndef objective_max(x):\n    # x is an array [u1, u2]\n    return -1*sum_T_func(x[0], x[1])\n\n# Initial guess for u1, u2\nu_init = np.array([0.1, 0.1])\n\n# Define the bounds: (0.01<u1<0.7, 0.03<u2<3)\nbounds = Bounds([0.01, 0.03], [0.7, 3])\n\n# Minimize the function with constraints\nresult = minimize(objective, u_init, bounds=bounds)\nresult_max = minimize(objective_max, u_init, bounds=bounds)\n\n# Print the results\nprint(\"Optimal values:\", result.x)\nprint(\"Minimum value:\", result.fun)\nprint(\"Optimal values:\", result_max.x)\nprint(\"Maximum value:\", -result_max.fun)\n\nThe picture shows the MBB of the reachable set of system to\ninputs \\beta \\in [0.01,\\ 0.7] and \\gamma \\in [0.03, \\ 3]\nfor t = 1s.","type":"content","url":"/examples#optimization-and-reachability","position":39},{"hierarchy":{"lvl1":"Examples","lvl3":"Interpretation","lvl2":"SEIRS"},"type":"lvl3","url":"/examples#interpretation","position":40},{"hierarchy":{"lvl1":"Examples","lvl3":"Interpretation","lvl2":"SEIRS"},"content":"For small inputs and short time horizons, the truncated Chen–Fliess\nseries provides an accurate approximation of the pendulum’s output.\nThe error increases with:\n\ntruncation depth\n\ninput amplitude\n\nand time horizon\n\nThis example demonstrates how Chen–Fliess expansions capture nonlinear\ndynamics through iterated integrals and Lie derivatives, providing a\npowerful tool for analysis, approximation, and reachability.","type":"content","url":"/examples#interpretation","position":41},{"hierarchy":{"lvl1":"Getting Started"},"type":"lvl1","url":"/getting-started","position":0},{"hierarchy":{"lvl1":"Getting Started"},"content":"This chapter provides a high-level overview of how to begin using\nCFSpy. It introduces the core workflow, explains the\nmain concepts, and walks through the essential steps for computing\nChen–Fliess expansions in practice.\n\nThe goal is to give you a clear mental model first, and then guide you\nthrough concrete examples.","type":"content","url":"/getting-started","position":1},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Content"},"type":"lvl2","url":"/getting-started#content","position":2},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Content"},"content":"installation\n\nbasic usage\n\niterated integrals\n\nvector field\n\nlie derivatives\n\ntruncated series\n\node comparison\n\npitfalls\n\nmore examples","type":"content","url":"/getting-started#content","position":3},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Installation"},"type":"lvl2","url":"/getting-started#installation","position":4},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Installation"},"content":"To install the CFSpy package, run the following command\nin your terminal.pip install --upgrade CFSpy\n\nThis will download and install the package along with its dependencies.\nMake sure you have Python 3.12.4 or higher installed on your system.","type":"content","url":"/getting-started#installation","position":5},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Basic Usage (High-Level Overview)"},"type":"lvl2","url":"/getting-started#basic-usage-high-level-overview","position":6},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Basic Usage (High-Level Overview)"},"content":"Once installed, CFSpy enables you to compute the\nbuilding blocks of the Chen–Fliess expansion:\n\nIterated integrals of the input\n\nLie derivatives of the output along the vector fields\n\nChen–Fliess coefficients (c,\\eta)\n\nTruncated Chen–Fliess series F_c^{N}[u](t)\n\nComparison with the true system output\n\nA typical workflow looks like this:flowchart TD\n    classDef step fill:#f2f2f2,stroke:#333,stroke-width:1px,rx:6px,ry:6px,color:black;\n\n    U[\"Inputs <br/> $$\\ u(t)$$\"]:::step\n    E[\"Iterated integrals<br/> $$\\ E^N_\\eta[u](t)$$\"]:::step\n    G[\"Vector fields<br/> $$\\ g_i$$\"]:::step\n    L[\"Lie derivatives<br/> $$\\ L_\\eta h$$\"]:::step\n    F[\"Chen–Fliess series<br/> $$\\ F_c^N[u](t)$$\"]:::step\n    O[\"Output of the system<br/>$$\\ h(t)$$\"]:::step\n\n    G --> L --> F\n    O --> L     \n    U --> E --> F\n\nThe sections below walk through each step in detail.","type":"content","url":"/getting-started#basic-usage-high-level-overview","position":7},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Computing iterated integrals"},"type":"lvl2","url":"/getting-started#computing-iterated-integrals","position":8},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Computing iterated integrals"},"content":"To compute the iterated integrals E_\\eta[u](t),\nyou must define:\n\ntime interval [0,t_f],\n\ninput function u(t),\n\nthe integration step dt.\n\ntruncation length Nfrom CFS import iter_int\nimport numpy as np\n\n# Time range\nt0 = 0\ntf = 3\ndt = 0.001\nt_span = (t0, tf)\nt = t0:dt:tf\n\n# inputs as arrays\nu1 = np.sin(t)\nu2 = np.cos(t)\n\n# input array\nu = np.vstack([u1, u2])\n\nNtrunc = 4\nE = iter_int(utemp, dt, Ntrunc)\n\nThis computes all iterated integrals E_\\eta[u](t) for\n|\\eta| \\le N.\n\nThe algorithm of the iter_int function is based on Chen’s identity\nwhich translates numerically to    \\begin{aligned}\n    E_{X^k}[u](t)=\\int _0^t u(t)\\otimes E_{X^{k-1}}[u](t) d\\tau .\n    \\end{aligned}\n\nwhere u(t) is the matrix of inputs stacked horizontally,\nE_{X^k}[u](t) is the matrix that stacks horizontally the iterated integrals\nand the tensor symbol \\otimes represents\nthe \n\ncolumn-wise Kronecker product.\n\nThe outline of the calculation of the algorithm follows the workflow:flowchart TD\n    classDef step fill:#f2f2f2,stroke:#333,stroke-width:1px,rx:6px,ry:6px,color:black;\n    classDef calc fill:#e8f0ff,stroke:#333,stroke-width:1px,rx:6px,ry:6px,color:black;\n    classDef loop fill:#fff4d6,stroke:#333,stroke-width:1px,rx:6px,ry:6px,color:black;\n\n    A[\"Start<br/><span> $$\\ ( u_{\\text{temp}}, dt, N_{\\text{trunc}})$$</span>\"]:::step\n\n    H[\"Compute first-order integrals: <span> $$\\ E_{X^1}[u](t) $$</span>\"]:::calc\n\n    I{\"Loop i = 1 to Ntrunc-1\"}:::loop\n\n    K[\"<span> $$\\ \\text{Etemp} = u(t)\\otimes E_{X^{i}}[u](t) $$</span>\"]:::calc\n    M[\"Compute: <span> $$\\ E_{X^{i+1}}[u](t) = \\int _0^t \\text{Etemp} d\\tau $$</span>\"]:::calc\n    N[\"Store <span> $$\\ E_{X^{i+1}}[u](t) $$</span>\"]:::step\n\n    O[\"Return the integral block\"]:::step\n\n    %% Connections\n    A --> H --> I\n    I --> K  --> M\n    M --> N --> I\n    I --> O","type":"content","url":"/getting-started#computing-iterated-integrals","position":9},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Defining vector fields and outputs"},"type":"lvl2","url":"/getting-started#defining-vector-fields-and-outputs","position":10},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Defining vector fields and outputs"},"content":"To compute Chen–Fliess coefficients (c,\\eta) = L_\\eta h,\nyou must define:\n\nthe drift vector field g_0(z),\n\nthe controlled vector fields g_i(z),\n\nthe output function h(z).\n\nExample:from CFS import iter_lie\nimport sympy as sp\n\n# Define the symbolic variables\nx1, x2 = sp.symbols('x1 x2')\nx = sp.Matrix([x1, x2])\n\n# Define the Lotka-Volterra system symbolically\ng = sp.transpose(sp.Matrix([[-x1*x2, x1*x2], \n                            [x1, 0], \n                            [0, - x2]\n                            ]))\n\n# Define the output symbolically\nh = x1","type":"content","url":"/getting-started#defining-vector-fields-and-outputs","position":11},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Computing Lie derivatives"},"type":"lvl2","url":"/getting-started#computing-lie-derivatives","position":12},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Computing Lie derivatives"},"content":"Lie derivatives encode the geometric structure of the system.# The truncation of the length of the words that index the Chen-Fliess series\nNtrunc = 4\n\n# Coefficients of the Chen-Fliess series evaluated at the initial state\nCeta = np.array(iter_lie(h,g,x,Ntrunc).subs([(x[0], 1/3),(x[1], 2/3)]))\n\nSimilarly to the iterated integrals, the outline of the calculation of the algorithm follows the workflow:flowchart TD\n    classDef step fill:#f2f2f2,stroke:#333,stroke-width:1px,rx:6px,ry:6px,color:black;\n    classDef calc fill:#e8f0ff,stroke:#333,stroke-width:1px,rx:6px,ry:6px,color:black;\n    classDef loop fill:#fff4d6,stroke:#333,stroke-width:1px,rx:6px,ry:6px,color:black;\n\n    A[\"Start<br/><span> $$\\ ( g_i(z), h(z),  N_{\\text{trunc}})$$</span>\"]:::step\n\n    H[\"Compute first-order Lie derivatives: <span> $$\\ L_{X^1}h(z) $$</span>\"]:::calc\n\n    I{\"Loop i = 1 to Ntrunc-1\"}:::loop\n\n    K[\"<span> $$\\ \\text{Ltemp} = \\frac{\\partial}{\\partial z}L_{X^i}h(z) $$</span>\"]:::calc\n    M[\"Compute: <span> $$\\  g\\otimes \\text{Ltemp} $$</span>\"]:::calc\n    N[\"Store <span> $$\\ L_{X^{i+1}}h(z) $$</span>\"]:::step\n\n    O[\"Return the Lie derivative block\"]:::step\n\n    %% Connections\n    A --> H --> I\n    I --> K  --> M\n    M --> N --> I\n    I --> O","type":"content","url":"/getting-started#computing-lie-derivatives","position":13},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Computing truncated Chen–Fliess series"},"type":"lvl2","url":"/getting-started#computing-truncated-chen-fliess-series","position":14},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Computing truncated Chen–Fliess series"},"content":"Once iterated integrals and Lie derivatives are available, you can\nassemble the truncated Chen–Fliess series:# Chen-Fliess series\nF_cu = x0[0]+np.sum(Ceta*Eu, axis = 0)\n\nThis returns a numerical approximation ofF_c^{N}[u](t) = \\sum_{|\\eta| \\le N} (c, \\eta)\\, E_\\eta[u](t).","type":"content","url":"/getting-started#computing-truncated-chen-fliess-series","position":15},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Comparing with ODE simulation"},"type":"lvl2","url":"/getting-started#comparing-with-ode-simulation","position":16},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Comparing with ODE simulation"},"content":"To validate the approximation, compare it with the true system output.from scipy.integrate import solve_ivp\n\n# Time range\nt0 = 0\ntf = 3\ndt = 0.001\nt_span = (t0, tf)\n\n# Define the Lotka-Volterra system\ndef system(t, x, u1_func, u2_func):\n    x1, x2 = x\n    u1 = u1_func(t)\n    u2 = u2_func(t)\n    dx1 = -x1*x2 +  x1 * u1\n    dx2 = x1*x2 - x2* u2\n    return [dx1, dx2]\n\n# Input 1\ndef u1_func(t):\n    return np.sin(t)\n\n# Input 2\ndef u2_func(t):\n    return np.cos(t)\n\n# Simulation of the system\nsolution = solve_ivp(system, t_span, x0, args=(u1_func, u2_func), dense_output=True)\n\n# Partition of the time interval\nt = np.linspace(t_span[0], t_span[1], int((tf-t0)//dt+1))\ny = solution.sol(t)","type":"content","url":"/getting-started#comparing-with-ode-simulation","position":17},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Common pitfalls"},"type":"lvl2","url":"/getting-started#common-pitfalls","position":18},{"hierarchy":{"lvl1":"Getting Started","lvl2":"Common pitfalls"},"content":"Mismatched dimensions: Inputs must have shape (m+1, length(t)).\n\nTranspose required: Use g = (g0', g1', g2')'.\n\nLarge truncation depth: Word count grows combinatorially.\n\nVector fields should be symbolic for compliance.\n\nIndexing inside ODE solvers must match the time grid.","type":"content","url":"/getting-started#common-pitfalls","position":19},{"hierarchy":{"lvl1":"Getting Started","lvl2":"More examples"},"type":"lvl2","url":"/getting-started#more-examples","position":20},{"hierarchy":{"lvl1":"Getting Started","lvl2":"More examples"},"content":"For more detailed examples and advanced usage,\nsee the \n\nexamples of the documentation.","type":"content","url":"/getting-started#more-examples","position":21},{"hierarchy":{"lvl1":"Introduction"},"type":"lvl1","url":"/introduction","position":0},{"hierarchy":{"lvl1":"Introduction"},"content":"This is meant to be a quick introduction to the subject.\nThe CFSpy Python package is developed to\ncompute Chen–Fliess series numerically.\nChen–Fliess series provide an input–output representation\nof nonlinear control-affine systems described in general\nby the following set of equations:\\begin{aligned}\n\\dot{z} &= g_0(z) + \\sum_{i = 1}^{m} g_i(z) u_i\\\\\ny &= h(z)\n\\end{aligned}\n\nThe vector fields g_i and the output function h are analytic,\nand u_i, y, z denote the input, output, and state of the system,\nrespectively.","type":"content","url":"/introduction","position":1},{"hierarchy":{"lvl1":"Introduction","lvl2":"Why Chen–Fliess series?"},"type":"lvl2","url":"/introduction#why-chen-fliess-series","position":2},{"hierarchy":{"lvl1":"Introduction","lvl2":"Why Chen–Fliess series?"},"content":"The Chen–Fliess series provides a powerful way to describe the input–output\nbehavior of nonlinear systems without explicitly solving the underlying\ndifferential equations. It converts the dynamics into an infinite formal\npower series whose coefficients encode the geometry of the vector fields\nand whose terms depend on iterated integrals of the input.\n\nThis representation is particularly useful for:\n\napproximating system outputs,\n\nanalyzing nonlinear controllability,\n\ncomputing high-order expansions,\n\nbenchmarking numerical methods,\n\nand studying operator-theoretic properties of control systems.\n\nThe Chen–Fliess series has the form:\\begin{aligned}\nF_c[u](t) = \\sum_{\\eta \\in X^*} (c, \\eta) E_{\\eta}[u](t)\n\\end{aligned}","type":"content","url":"/introduction#why-chen-fliess-series","position":3},{"hierarchy":{"lvl1":"Introduction","lvl2":"Understanding the algebraic structure"},"type":"lvl2","url":"/introduction#understanding-the-algebraic-structure","position":4},{"hierarchy":{"lvl1":"Introduction","lvl2":"Understanding the algebraic structure"},"content":"To understand the elements of this series, consider the\n\n\nfree monoid\n(X^\\ast, \\cdot, \\emptyset) where X^* is the set of all words\nover the alphabet X = \\{x_0, \\ldots, x_m\\}.\n\nIntuitively, each word \\eta = x_{i_1}\\cdots x_{i_k} represents a\ncomposition of vector fields applied in a specific order.\nThe symbol x_0 corresponds to the drift vector field g_0,\nwhile x_i corresponds to the controlled vector field g_i.\n\nThe coefficients (c, \\eta) correspond to the word \\eta\nin the generating series c=\\sum_{\\eta\\in X^\\ast}(c,\\eta)\\eta,\nand E_{\\eta}[u](t) is the iterated integral corresponding to the word\n\\eta and the input function u.","type":"content","url":"/introduction#understanding-the-algebraic-structure","position":5},{"hierarchy":{"lvl1":"Introduction","lvl2":"Definition of iterated integrals"},"type":"lvl2","url":"/introduction#definition-of-iterated-integrals","position":6},{"hierarchy":{"lvl1":"Introduction","lvl2":"Definition of iterated integrals"},"content":"The iterated integral is defined recursively as E_{\\emptyset}[u](t)=1 and    E_{x_{i}\\eta}[u](t)\n    = \\int_0^t u_{x_i}(\\tau)\\,E_{\\eta}[u](\\tau)\\,d\\tau","type":"content","url":"/introduction#definition-of-iterated-integrals","position":7},{"hierarchy":{"lvl1":"Introduction","lvl2":"Definition of Lie derivatives"},"type":"lvl2","url":"/introduction#definition-of-lie-derivatives","position":8},{"hierarchy":{"lvl1":"Introduction","lvl2":"Definition of Lie derivatives"},"content":"The Lie derivative of :math:h associated to the word \\eta is defined as    L_{\\eta}h = L_{x_{i_1}}\\cdots L_{x_{i_k}}h\n\nwhere L_{x_{i_j}}h=\\frac{\\partial h}{\\partial z}\\cdot g_{i_j}.\n\nUnder the \n\nproper conditions (Fliess, 1983),\nwe have the identity    (c, \\eta) = L_{\\eta}h","type":"content","url":"/introduction#definition-of-lie-derivatives","position":9},{"hierarchy":{"lvl1":"Introduction","lvl2":"A concrete example"},"type":"lvl2","url":"/introduction#a-concrete-example","position":10},{"hierarchy":{"lvl1":"Introduction","lvl2":"A concrete example"},"content":"For example, the word \\eta = x_2 x_0 x_1 corresponds to the Lie derivative    L_{x_2 x_0 x_1} h\n    = L_{x_2}(L_{x_0}(L_{x_1} h)).\n\nThe associated iterated integral is    E_{x_2 x_0 x_1}[u](t)\n    = \\int_0^t u_2(\\tau_3)\n        \\int_0^{\\tau_3} u_0(\\tau_2)\n            \\int_0^{\\tau_2} u_1(\\tau_1)\\, d\\tau_1\\, d\\tau_2\\, d\\tau_3.","type":"content","url":"/introduction#a-concrete-example","position":11},{"hierarchy":{"lvl1":"Introduction","lvl2":"Practical use and truncation"},"type":"lvl2","url":"/introduction#practical-use-and-truncation","position":12},{"hierarchy":{"lvl1":"Introduction","lvl2":"Practical use and truncation"},"content":"In applications, the infinite series in \n\n1 is truncated at some depth N.\nUnder analyticity assumptions, the truncated series converges uniformly on compact\ntime intervals for sufficiently small inputs. The truncation depth controls the\naccuracy of the approximation, and CFSpy provides tools to study\nthis trade-off numerically.","type":"content","url":"/introduction#practical-use-and-truncation","position":13},{"hierarchy":{"lvl1":"Introduction","lvl2":"What the package does"},"type":"lvl2","url":"/introduction#what-the-package-does","position":14},{"hierarchy":{"lvl1":"Introduction","lvl2":"What the package does"},"content":"The CFSpy package implements these constructions efficiently by:\n\ncomputing Lie derivatives symbolically or numerically,\n\ngenerating all words up to a chosen truncation depth,\n\nevaluating iterated integrals using high-performance numerical routines,\n\nassembling truncated Chen–Fliess approximations,\n\nand comparing them with ODE solutions for validation.\n\nThis allows users to explore high-order expansions, benchmark algorithms,\nand study nonlinear systems without manually handling the combinatorial\ncomplexity of words and iterated integrals.","type":"content","url":"/introduction#what-the-package-does","position":15},{"hierarchy":{"lvl1":"Introduction","lvl2":"Summary of the Chen–Fliess pipeline"},"type":"lvl2","url":"/introduction#summary-of-the-chen-fliess-pipeline","position":16},{"hierarchy":{"lvl1":"Introduction","lvl2":"Summary of the Chen–Fliess pipeline"},"content":"Define the vector fields g_i and output h.\n\nGenerate all words \\eta up to length N.\n\nCompute Lie derivatives L_\\eta h.\n\nCompute iterated integrals E_\\eta[u](t).\n\nForm the truncated series\nF_c^{N} = \\sum_{|\\eta|\\le N} (c,\\eta) E_\\eta[u](t).\n\nCompare with the true system output if desired.","type":"content","url":"/introduction#summary-of-the-chen-fliess-pipeline","position":17},{"hierarchy":{"lvl1":"CFSpy"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"CFSpy"},"content":"\n\n \n\n  \n\n \n\n\n\nWelcome to the documentation of the CFSpy Python package.","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"CFSpy","lvl2":"Overview"},"type":"lvl2","url":"/#overview","position":2},{"hierarchy":{"lvl1":"CFSpy","lvl2":"Overview"},"content":"CFSpy is used for the computation of Chen-Fliess series and their applications in control and reachability theory. This documentation provides a comprehensive guide to using and contributing to the project.\n\nThe package provides the following functionalities:\n\nThe list of iterated integrals indexed by words of a certain length or less.\n\nThe list of Lie derivatives indexed by words of a certain length or less.\n\nA single iterated integral indexed by a given word.\n\nA single Lie derivative indexed by a given word.\n\nThe symbolic polynomial that represents the Chen-Fliess series for a constant input.\n\nThe implementation is based on Chen’s identity, which provides recursive relations between iterated integrals and Lie derivatives, significantly reducing redundant computation.\n\nThis package is the first publicly available open‑source implementation of these tools in the Python ecosystem, relying only on NumPy and SymPy for minimal and efficient dependencies.","type":"content","url":"/#overview","position":3},{"hierarchy":{"lvl1":"CFSpy","lvl2":"What are Chen–Fliess series?"},"type":"lvl2","url":"/#what-are-chen-fliess-series","position":4},{"hierarchy":{"lvl1":"CFSpy","lvl2":"What are Chen–Fliess series?"},"content":"Chen–Fliess series provide an input–output representation of analytic\nnonlinear control‑affine systems.They express the output as a formal power series whose coefficients are\nLie derivatives of the output function and whose terms are iterated\nintegrals of the input.\n\nFormally:    F_c[u](t) = \\sum_{\\eta \\in X^*} (c,\\eta)\\, E_\\eta[u](t),\n\nwhere:\n\n\\eta is a word over the alphabet X = \\{x_0,\\ldots,x_m\\},\n\n(c,\\eta) is the coefficient given by a Lie derivative,\n\nE_\\eta[u](t) is the iterated integral associated with \\eta.\n\nThese series play a central role in nonlinear control theory, system\napproximation, and operator‑theoretic analysis.","type":"content","url":"/#what-are-chen-fliess-series","position":5},{"hierarchy":{"lvl1":"CFSpy","lvl2":"Why Python?"},"type":"lvl2","url":"/#why-python","position":6},{"hierarchy":{"lvl1":"CFSpy","lvl2":"Why Python?"},"content":"CFSpy is written in Python to leverage:\n\nHigh performance: JIT compilation and type specialization enable tight inner loops for iterated integrals and Lie derivatives.\n\nMultiple dispatch: Natural expression of different system types, vector field representations, and numeric backends.\n\nSymbolic–numeric synergy: Seamless integration with Symbolics.jl for symbolic Lie derivatives and LinearAlgebra for efficient evaluation.\n\nInteractive workflows: Notebooks and REPL‑driven exploration make it easy to prototype, visualize, and benchmark Chen–Fliess expansions.","type":"content","url":"/#why-python","position":7},{"hierarchy":{"lvl1":"CFSpy","lvl2":"Citing this package"},"type":"lvl2","url":"/#citing-this-package","position":8},{"hierarchy":{"lvl1":"CFSpy","lvl2":"Citing this package"},"content":"If you use CFSpy in academic work, please cite it as:title        = {CFSpy},\nauthor       = {Perez Avellaneda, Ivan},\nyear         = {2024},\nurl          = {https://github.com/iperezav/CFSpy},\nnote         = {Python package version 1.2.3}\n\nA \n\nCITATION.bib file is also included in the repository.","type":"content","url":"/#citing-this-package","position":9},{"hierarchy":{"lvl1":"CFSpy","lvl2":"Content"},"type":"lvl2","url":"/#content","position":10},{"hierarchy":{"lvl1":"CFSpy","lvl2":"Content"},"content":"Introduction\n\nWhy Chen–Fliess series?\n\nUnderstanding the algebraic structure\n\nDefinition of iterated integrals\n\nDefinition of Lie derivatives\n\nA concrete example\n\nPractical use and truncation\n\nWhat the package does\n\nSummary of the Chen–Fliess pipeline\n\nGetting Started\n\nInstallation\n\nBasic Usage (High-Level Overview)\n\nComputing iterated integrals\n\nDefining vector fields and outputs\n\nComputing Lie derivatives\n\nComputing truncated Chen–Fliess series\n\nComparing with ODE simulation\n\nCommon pitfalls\n\nMore examples\n\nExamples\n\nLotka-Volterra\n\nSystem dynamics\n\nDefining the system in Python\n\nInput signal\n\nComputing iterated integrals\n\nComputing Lie derivatives\n\nAssembling the truncated Chen-Fliess series\n\nSimulating the true Lotka-Volterra dynamics\n\nComparison plot\n\nSEIRS\n\nSystem dynamics\n\nDefining the system in Python\n\nInput signal\n\nComputing iterated integrals\n\nComputing Lie derivatives\n\nAssembling the truncated Chen–Fliess series\n\nSimulating the true SEIRS dynamics\n\nComparison plot\n\nOptimization and Reachability\n\nInterpretation\n\nContributing\n\nHow to Contribute\n\nGuidelines","type":"content","url":"/#content","position":11}]}