# Examples

This section provides practical demonstrations of how to use
**CFSpy** for computing iterated integrals, Lie derivatives,
and truncated Chen–Fliess series for nonlinear control‑affine systems.

Each example illustrates a complete workflow:

1. Define vector fields and outputs  
2. Compute Lie derivatives  
3. Compute iterated integrals  
4. Assemble the truncated Chen–Fliess series  
5. Compare with a numerical ODE solution  

Two representative systems are shown below:  
a Lotka-Volterra and a SEIRS system.


## Lotka-Volterra

This example demonstrates how to compute Lie derivatives, iterated integrals,
and a truncated Chen–Fliess approximation for a simplified planar quadrotor.


### System dynamics

We consider the standard control–affine Lotka-Volterra model:

```{math}
    \begin{aligned}
    \dot{x}_1 &= -x_1 x_2 + x_1 u_1, \\
    \dot{x}_2 &= x_1 x_2 - x_2 u_2, 
    \end{aligned}
```

with output

```{math}
    y = h(x) = x_1.
```

This can be written in control–affine form

```{math}
    \dot{x} = g_0(x) + g_1(x) u_1(t) + g_2(x) u_2(t),
```

where

```{math}
    g_0(x) = \begin{bmatrix} -x_1 x_2 \\ x_1 x_2 \end{bmatrix},
    \quad
    g_1(x) = \begin{bmatrix} x_1 \\ 0  \end{bmatrix},
    \quad
    g_2(x) = \begin{bmatrix} 0 \\ -x_2 \end{bmatrix}.
```

### Defining the system in Python


```python
import sympy as sp

# Define the symbolic variables
x1, x2 = sp.symbols('x1 x2')
x = sp.Matrix([x1, x2])

# The truncation of the length of the words that index the Chen-Fliess series
Ntrunc = 4
h = x[1]                  # output: horizontal position

# Define the system symbolically
g = sp.transpose(sp.Matrix([[-x1*x2, x1*x2], [x1, 0], [0, - x2]]))

# Define the output symbolically
h = x1
```

### Input signal


```python
import numpy as np
# Time range
t0 = 0
tf = 3
dt = 0.001
t_span = (t0, tf)
# Partition of the time interval
t = np.linspace(t_span[0], t_span[1], int((tf-t0)//dt+1))
# inputs as arrays
u1 = np.sin(t)
u2 = np.cos(t)

# input array
u = np.vstack([u1, u2])
```

### Computing iterated integrals


```python
from CFS import iter_int
# List of iterated integral
Eu = iter_int(u,t0, tf, dt, Ntrunc)
```

### Computing Lie derivatives



```python
from CFS import iter_lie
# Initial condition
x0 = [1/3,2/3]
# Coefficients of the Chen-Fliess series evaluated at the initial state
Ceta = np.array(iter_lie(h,g,x,Ntrunc).subs([(x[0], x0[0]),(x[1], x0[1])]))
```

### Assembling the truncated Chen-Fliess series


```python
# Chen-Fliess series
F_cu = x0[0]+np.sum(Ceta*Eu, axis = 0)
```


### Simulating the true Lotka-Volterra dynamics

```python
from scipy.integrate import solve_ivp

# Define the Lotka-Volterra system
def system(t, x, u1_func, u2_func):
    x1, x2 = x
    u1 = u1_func(t)
    u2 = u2_func(t)
    dx1 = -x1*x2 +  x1 * u1
    dx2 = x1*x2 - x2* u2
    return [dx1, dx2]

# Input 1
def u1_func(t):
    return np.sin(t)

# Input 2
def u2_func(t):
    return np.cos(t)


# Initial condition
x0 = [1/3,2/3]

# time
t0 = 0
tf = 3
dt = 0.001
t_span = (t0, tf)

# Simulation of the system
solution = solve_ivp(system, t_span, x0, args=(u1_func, u2_func), dense_output=True)
# Partition of the time interval
t = np.linspace(t_span[0], t_span[1], int((tf-t0)//dt+1))
y = solution.sol(t)
```    

### Comparison plot


```python
import matplotlib.pyplot as plt
# Graph of the output and the Chen-Fliess series
plt.figure(figsize = (12,5))
plt.plot(t, y[0].T)
plt.plot(t, F_cu, color='red', linewidth=5, linestyle = '--', alpha = 0.5)
plt.xlabel('$t$')
plt.ylabel('$x_1$')
plt.legend(['Output of the system','Chen-Fliess series'])
plt.grid()
plt.show()
```

![Ivan Perez Avellaneda](images/output_chenfliess.png)


## SEIRS


This example illustrates how to compute a truncated Chen–Fliess series
for a SEIRS (Susceptible-Exposed-Infectious-Recovered-Susceptible) with torque input and compare it with the true
ODE solution.

### System dynamics


We consider the standard control–affine SEIRS model:

```{math}
\begin{aligned}
    \dot{x}_1 &= \mu N - u_1 x_3 x_1 / N + \omega  x_4 - \mu  x_1 \\
    \dot{x}_2 &= u_1 x_3 x_1 / N - \sigma  x_2 - \mu x_2 \\
    \dot{x}_3 &= \sigma  x_2 - u_2 x_3 - (\mu + \alpha)  x_3 \\
    \dot{x}_4 &= u_2 x_3 - (\omega + \mu) x_4
\end{aligned}
```

with output

```{math}
y = h(x) = x_1.
```

This can be written in control–affine form

```{math}
\dot{x} = g_0(x) + g_1(x) u_1(t)+ g_2(x) u_2(t),
```

where

```{math}
g_0(z) = \begin{bmatrix} \omega  x_4 - \mu  x_1 \\ - \sigma  x_2 - \mu x_2 \\ \sigma  x_2 - (\mu + \alpha)  x_3 \\ - (\omega + \mu) x_4 \end{bmatrix},
\quad
g_1(z) = \begin{bmatrix} - x_3 x_1 / N \\ x_3 x_1 / N \\ 0 \\ 0 \end{bmatrix},
\quad
g_1(z) = \begin{bmatrix} 0 \\ 0 \\ -x_3 \\ x_3 \end{bmatrix}.
```


### Defining the system in Python


```python
import sympy as sp
# Define the symbolic variables
x1, x2, x3, x4 = sp.symbols('x1 x2 x3 x4')
x = sp.Matrix([x1, x2, x3, x4])


# Define the system symbolically
mu = 1 / 76
omega = 1 
sigma = 1 / 7
alpha = 0
N = 1.0
g = sp.transpose(sp.Matrix([[mu * N + omega * x4 - mu * x1, - sigma * x2 - mu * x2, sigma * x2 - (mu + alpha) * x3, - omega * x4 - mu * x4], \
                            [-x3 * x1 / N, x3 * x1 / N, 0, 0], [0, 0, - x3, x3]]))

# Define the output symbolically
h = x1

# The truncation of the length of the words that index the Chen-Fliess series
Ntrunc = 6
```

### Input signal

```python
import numpy as np
# Time range
t0 = 0
tf = 3
dt = 0.001
t_span = (t0, tf)
t = np.linspace(t_span[0], t_span[1], int((tf-t0)//dt+1))
# inputs as arrays
u1 = np.sin(t)
u2 = np.cos(t)

# input array
u = np.vstack([u1, u2])

```

### Computing iterated integrals


```python
# List of iterated integral
Eu = iter_int(u,t0, tf, dt, Ntrunc)
```

### Computing Lie derivatives


```python
# Initial condition
x0 = [0.999, 0.001, 0.0, 0.0]
# The truncation of the length of the words that index the Chen-Fliess series
Ntrunc = 6
# Coefficients of the Chen-Fliess series evaluated at the initial state
Ceta = np.array(iter_lie(h,g,x,Ntrunc).subs([(x[0], x0[0]),(x[1], x0[1]), (x[2], x0[2]), (x[3], x0[3])]))

```

### Assembling the truncated Chen–Fliess series


```python
# Chen-Fliess series
F_cu = x0[0]+np.sum(Ceta*Eu, axis = 0)
```

### Simulating the true SEIRS dynamics


```python
from scipy.integrate import solve_ivp

mu = 1 / 76
omega = 1 
sigma = 1 / 7
alpha = 0
N = 1.0

# Define the SEIRS system
def system(t, x, u1_func, u2_func):
    x1, x2, x3, x4 = x
    u1 = u1_func(t)
    u2 = u2_func(t)
    dx1 = mu * N - u1 * x3 * x1 / N + omega * x4 - mu * x1
    dx2 = u1 * x3 * x1 / N - sigma * x2 - mu * x2
    dx3 = sigma * x2 - u2 * x3 - (mu + alpha) * x3
    dx4 = u2 * x3 - omega * x4 - mu * x4
    return [dx1, dx2, dx3, dx4]

# Input 1
def u1_func(t):
    return np.sin(t)

# Input 2
def u2_func(t):
    return np.cos(t)

# Simulation of the system
solution = solve_ivp(system, t_span, x0, args=(u1_func, u2_func), dense_output=True)

# Partition of the time interval
t = np.linspace(t_span[0], t_span[1], int((tf-t0)//dt+1))
y = solution.sol(t)
```

### Comparison plot


```python
import matplotlib.pyplot as plt

plt.figure(figsize = (12,5))
plt.plot(t, y[0].T)
plt.plot(t, F_cu, color='red', linewidth=5, linestyle = '--', alpha = 0.5)
plt.xlabel('$t$')
plt.ylabel('$x_1$')
plt.legend(['Output of the system','Chen-Fliess series'])
plt.grid()
plt.show()
```

![Ivan Perez Avellaneda](images/SEIRS.png)

### Optimization and Reachability


```python
from scipy.optimize import minimize
from scipy.optimize import Bounds
# Convert symbolic expression to a numerical function using lambdify
sum_T_func = sp.lambdify([u1, u2], sp.Matrix(F_cu_substituted), 'numpy')

# Define the objective function for scipy.optimize
def objective(x):
    # x is an array [u1, u2]
    return sum_T_func(x[0], x[1])

def objective_max(x):
    # x is an array [u1, u2]
    return -1*sum_T_func(x[0], x[1])

# Initial guess for u1, u2
u_init = np.array([0.1, 0.1])

# Define the bounds: (0.01<u1<0.7, 0.03<u2<3)
bounds = Bounds([0.01, 0.03], [0.7, 3])

# Minimize the function with constraints
result = minimize(objective, u_init, bounds=bounds)
result_max = minimize(objective_max, u_init, bounds=bounds)

# Print the results
print("Optimal values:", result.x)
print("Minimum value:", result.fun)
print("Optimal values:", result_max.x)
print("Maximum value:", -result_max.fun)
```

![Ivan Perez Avellaneda](images/MBB.png)

### Interpretation


For small inputs and short time horizons, the truncated Chen–Fliess
series provides an accurate approximation of the pendulum’s output.
The error increases with:

- truncation depth
- input amplitude
- and time horizon

This example demonstrates how Chen–Fliess expansions capture nonlinear
dynamics through iterated integrals and Lie derivatives, providing a
powerful tool for analysis, approximation, and reachability.